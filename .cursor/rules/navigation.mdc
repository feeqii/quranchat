---
description: Outlines the complete navigation architecture of Quran Chat using React Navigation. It defines two main flows â€” the onboarding stack and the main app stack â€” and shows how users are routed based on whether they've completed onboarding. This document ensures all navigation is clean, centralized, and logic-driven, avoiding hardcoded routes and UI-level decisions.  Use this to:  Configure navigation across onboarding and post-onboarding flows  Prevent inconsistent routing or back behavior  Help Claude structure screens with correct routing logic  Keep app transitions smooth and predictable
globs: 
alwaysApply: false
---
# Quran Chat â€“ Navigation Structure

This document defines the full navigation flow of the Quran Chat app using React Navigation (stack-based). It separates onboarding from the main app and ensures users are routed properly based on onboarding completion status.

---

## ğŸ“¦ Navigation Library

- **React Navigation Stack** (`@react-navigation/native-stack`)
- Optional: wrap entire app in `NavigationContainer` with gesture + safe area support
- Screens are registered in a central `AppNavigator.tsx`

---

## ğŸ“ Navigation Flow (High Level)

```
App.tsx â†’
  AppNavigator â†’
    [if onboardingCompleted == false]
      â†’ OnboardingStack
    [else]
      â†’ MainAppStack
```

---

## ğŸªœ OnboardingStack

Linear stack of 12 screens (see `screen_requirements.md` for details):

```
OnboardingWelcomeScreen
â†’ OnboardingStep1
â†’ OnboardingStep2
â†’ OnboardingStep3
â†’ OnboardingStep4
â†’ OnboardingStep5
â†’ OnboardingStep6
â†’ OnboardingStep7
â†’ OnboardingStep8
â†’ OnboardingStep9
â†’ OnboardingStep10
â†’ OnboardingFinalScreen (optional if different)
â†’ MainApp (redirect)
```

- Transitions should be **smooth fade or slide-right**
- Back gesture is **enabled**, but back button should be hidden on some screens

---

## ğŸ•Œ MainAppStack (Post-Onboarding)

Basic structure for now (to be expanded later):

```
HomeScreen (main chat interface)
â†’ HistoryScreen
â†’ SettingsScreen (optional)
```

---

## ğŸ”„ Skip Logic

In `AppNavigator.tsx`:

```ts
const { onboardingCompleted } = useOnboardingStore();

return (
  <NavigationContainer>
    <Stack.Navigator screenOptions={{ headerShown: false }}>
      {onboardingCompleted ? (
        <Stack.Screen name="MainApp" component={MainAppStack} />
      ) : (
        <Stack.Screen name="Onboarding" component={OnboardingStack} />
      )}
    </Stack.Navigator>
  </NavigationContainer>
);
```

---

## ğŸ’¬ Navigation Helpers

Use the `useNavigation()` hook or `navigation.navigate("ScreenName")` consistently.

Screens should never hardcode routes â€” always use registered screen names from `AppNavigator`.

---

## ğŸ§¼ Naming Conventions

- Screens are **PascalCase**, matching file names exactly
- Route names should match component names to avoid bugs
- Never define routes inline in screen files

---

## ğŸ” Guarding Routes (Optional)

If needed later:
- Protect `MainAppStack` routes from being accessed before onboarding
- Redirect via effect in `AppNavigator` or create an `OnboardingGate` component

---

## âœ… Rules

- Never define navigation logic inside screens directly  
- Always handle conditional routing in `AppNavigator.tsx`  
- Always check Zustand's `onboardingCompleted` before routing to main app

